package de.ronny_h.aoc.year24.day17

import de.ronny_h.aoc.AdventOfCode
import de.ronny_h.aoc.extensions.memoize

fun main() = ChronospatialComputer().run("4,1,7,6,4,1,0,2,7", "164279024971453")

class ChronospatialComputer : AdventOfCode<String>(2024, 17) {
    override fun part1(input: List<String>): String {
        return ThreeBitComputer(input).runProgram().joinToString(",")
    }

    fun part2BruteForce(input: List<String>): String {
        val computer = ThreeBitComputer(input)
        val state = computer.save()
        var registerA = 0L
        while (computer.runProgram() != computer.program) {
            registerA++
            computer.restore(state, registerA)
        }
        return "$registerA"
    }

    override fun part2(input: List<String>): String {
        val computer = ThreeBitComputer(input)
        val program = computer.program
        val binarySolution = findSmallestRegisterAValueToOutputTheProgram(program)
        val solution = binarySolution.toLong(2)

        // validate the solution using the emulated 3-bit computer
        computer.restore(computer.save(), solution)
        val output = computer.runProgram()
        check(output == program)

        println("binary solution: $binarySolution")
        println("as Long: $solution")
        return "$solution"
    }
}

fun findSmallestRegisterAValueToOutputTheProgram(program: List<Int>): String {
    val programValues = program.toSet()  // the numbers to generate

    // there are 0..1111111 possibilities to generate one number
    // (C is shifted right max 7 digits, only lowest 3 digits of remaining C count for output)
    val max = "1111111111".toInt(2)
    val resultByInput = mutableMapOf<Int, MutableList<Int>>()
    (0..max).map {
        it to runTheProgramOneIteration(it.toLong())
    }.forEach { (a, out) ->
        if (out in programValues) {
            resultByInput.getOrPut(out) { mutableListOf() }.add(a)
        }
    }
    val outProducing = programValues.sorted().associateWith { out ->
        val generatedBy = resultByInput.getValue(out)
        println("$out can be generated by $generatedBy ${generatedBy.size}")
        generatedBy.map { it.toString(2).padStart(3, '0') }
    }
    val outProducingSortedByLowest3Bits = outProducing.mapValues { (_, producedBy) ->
        // sort by lowest 3 bits because of (*)
        producedBy.sortedBy { it.substring(it.length - 3) }
    }

    fun checkSolution(candidate: String): Boolean {
        val registerA = candidate.toLong(2)
        val result = runTheProgramsActualImplementation(registerA)
        return result == program
    }

    fun findSolution(
        remainingProgram: List<Int>,
        solutionSoFar: String,
    ): String {

        data class RecursionState(
            val remainingProgram: List<Int>,
            val solutionSoFar: String,
        )

        lateinit var findSolutionRec: (RecursionState) -> Pair<String, Boolean>

        findSolutionRec = { state: RecursionState ->
            if (state.remainingProgram.isEmpty()) {
                // due to larger overlaps than the chosen ones there might be higher digits leading to a different output
                // -> check if the solution indeed is one
                state.solutionSoFar to checkSolution(state.solutionSoFar)
            } else {
                val p = state.remainingProgram.first()
                // (*) from outProducing[p] take that number whose digits higher than 3 matches the last bits of binarySolution and has minimal lowest 3 bits
                val possibleChoices = outProducingSortedByLowest3Bits.getValue(p)

                var result: Pair<String, Boolean> = state.solutionSoFar to false
                for (c in possibleChoices) {
                    if (c.length == 3) {
                        // an exactly 3 bit long minimal value found -> take it
                        val (solution, found) = findSolutionRec(
                            RecursionState(
                                state.remainingProgram.drop(1),
                                state.solutionSoFar + c
                            )
                        )
                        if (found) {
                            result = solution to true
                            break
                        } else {
                            continue
                        }
                    } else {
                        // search a longer value with minimal lowest 3 bits (see (*)) and matching overlapping bits
                        val higherBitsOfC = c.substring(0, c.length - 3)
                        val startIndex = state.solutionSoFar.length - higherBitsOfC.length
                        if (startIndex < 0) {
                            // overlap exceeds the current number of bits in binarySolution
                            continue
                        }
                        val overlappingBits = state.solutionSoFar.substring(startIndex)
                        if (higherBitsOfC == overlappingBits) {
                            // take the lowest 3 bits; the higher ones are matching
                            val (solution, found) = findSolutionRec(
                                RecursionState(
                                    state.remainingProgram.drop(1),
                                    state.solutionSoFar + c.substring(c.length - 3)
                                )
                            )
                            if (found) {
                                result = solution to true
                                break
                            } else {
                                continue
                            }
                        }
                    }
                }
                result
            }
        }.memoize()

        return findSolutionRec(RecursionState(remainingProgram, solutionSoFar)).first
    }

    println("program: $program")
    // result can only be minimal if the minimal solution is used for the highest bit -> start with that
    val highestThreeBits = outProducing.getValue(program.last()).first()
    check(highestThreeBits.length == 3)
    val binarySolution = findSolution(program.dropLast(1).reversed(), highestThreeBits)
    return binarySolution
}

fun runTheProgramsActualImplementation(registerA: Long = 64854237L): List<Int> {
    var A = registerA
    val out = mutableListOf<Int>()
    do {
        out.add(runTheProgramOneIteration(A))
        A = A shr 3                 // 6: 0,3  A = A shr 3
    } while (A != 0L)               // 7: 3,0  A==0 ? end : goto 0
    return out
}

fun runTheProgramOneIteration(A: Long): Int {
    var B = A % 8                   // 0: 2,4  B = A  %  8        -> B = lowest 3 bits of A
    B = B xor 1                     // 1: 1,1  B = B xor 1 (001)  -> invert lowest bit of B
    val C = A shr B.toIntChecked()  // 2: 7,5  C = A shr B
    B = B xor 5                     // 3: 1,5  B = B xor 5 (101)  -> invert bit 0 and 2 of B
    B = B xor C                     // 4: 4,0  B = B xor C
    return (B % 8).toInt()          // 5: 5,5  out B  %  8        -> print lowest 3 bits of B
}

/**
 * - program = list of 3-bit numbers
 * - 3 registers: A, B, C of type Int
 * - 8 instructions: 3-bit opcode + 3-bit operand
 * - instruction pointer, increases by 2 after instruction processed if not jumped
 * - past the last opcode: program halts
 * - operands: literal or combo
 *
 * combo operands:
 * - 0-3: literal value 0-3
 * - 4, 5, 6: register A, B, C
 * - 7: reserved
 *
 * instructions:
 * opcode  instruction  function
 * 0       adv          division of A and 2^<combo operand>, truncated result in A
 * 1       bxl          bitwise XOR of B and literal operand, result in B
 * 2       bst          <combo operand> modulo 8, lowest 3 bits of result in B
 * 3       jnz          if A=0: nothing, else: jumps to <literal operand>
 * 4       bxc          bitwise XOR of B and C, result in B, reads but ignores operand
 * 5       out          <combo operand> modulo 8, then output result (multiple output values separated by ',')
 * 6       bdv          division of A and 2^<combo operand>, truncated result in B
 * 7       cdv          division of A and 2^<combo operand>, truncated result in C
 */
class ThreeBitComputer(input: List<String>) {

    private val instructionStep = 2

    val program = input.readProgram()
    private var registerA = input.readRegister('A')
    private var registerB = input.readRegister('B')
    private var registerC = input.readRegister('C')
    private var instructionPointer = 0

    private val output = mutableListOf<Int>()

    private val instructions: List<(Int) -> Unit> = listOf(
        { op -> registerA = (registerA shr combo(op).toIntChecked()); next() }, // 0 adv; A/2^x = A shr x
        { op -> registerB = (registerB xor op.toLong())             ; next() }, // 1 bxl
        { op -> registerB = (combo(op) % 8)                         ; next() }, // 2 bst; 7=111 -> take only lowest 3 bits
        { op -> if (registerA == 0L) next() else instructionPointer = op },     // 3 jnz
        { _  -> registerB = (registerB xor registerC)               ; next() }, // 4 bxc
        { op -> output.add((combo(op) % 8).toInt())                 ; next() }, // 5 out
        { op -> registerB = (registerA shr combo(op).toIntChecked()); next() }, // 6 bdv
        { op -> registerC = (registerA shr combo(op).toIntChecked()); next() }, // 7 cdv
    )

    fun runProgram(): List<Int> {
        while (instructionPointer < program.size) {
            val instruction = program[instructionPointer]
            val op = program[instructionPointer + 1]
            instructions[instruction].invoke(op)
        }
        return output
    }

    fun save() = State(registerA, registerB, registerC, instructionPointer)
    fun restore(state: State, registerAOverride: Long) {
        this.registerA = registerAOverride
        this.registerB = state.registerB
        this.registerC = state.registerC
        this.instructionPointer = state.instructionPointer
        this.output.clear()
    }

    private fun combo(op: Int) = when (op) {
        1 -> 1L
        2 -> 2L
        3 -> 3L
        4 -> registerA
        5 -> registerB
        6 -> registerC
        else -> error("unknown combo operand code '$op'")
    }

    private fun next() {
        instructionPointer += instructionStep
    }

    private fun List<String>.readRegister(register: Char) =
        first { it.startsWith("Register $register: ") }
            .substringAfter("Register $register: ")
            .toLong()

    private fun List<String>.readProgram() =
        first { it.startsWith("Program: ") }
            .substringAfter("Program: ")
            .split(",")
            .map(String::toInt)

    data class State(
        val registerA: Long,
        val registerB: Long,
        val registerC: Long,
        val instructionPointer: Int,
    )
}

private fun Long.toIntChecked(): Int {
    if (this > Int.MAX_VALUE) {
        throw IllegalArgumentException("$this exceeds Int range")
    }
    return this.toInt()
}
